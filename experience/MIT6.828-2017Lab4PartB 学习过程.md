# MIT6.828-2017Lab4PartB 学习过程

### 0.开始

实现`copy_on_write`。

实验的所有代码提交可参见[我的GitHub仓库](https://github.com/astzls213/MIT6.828-2017Lab)

我更建议大家看`github`仓库那个`experience`文件夹里头的，因为知乎对md格式排版不是很好。。最后，如果你觉得干货满满，可以点个赞鼓励下我！！求求了！如果有什么不懂的，可以评论留言告诉我。

**开始之前，我先跟大家讲下Part B的主要思想：**

要实现Copy-On-Write的fork，由于这个fork是用户定义的，那么我们就需要写一个自定义的页面出错处理程序（写映射页面时，复制该页面到自己的虚拟地址空间）。

那么，每当我们的进程出错时，首先就会到`page_fault_handler`里，而这个处理程序会直接kill掉我们的进程（我们不希望这样），所以我们需要看情况。

如果进程有自己的页面错误处理程序，`page_fault_handler`会引导进自己的错误处理程序。因此我们需要在进程控制块里添加一个成员，用来记录自己错误处理程序的地址。

那么，我们可以通过修改进程控制块的上下文记录，比如修改`tf_eip`使得`env_run`时能够去想要的地方执行指令。那么，我们这么做了以后，`Trapframe`就会出栈。

我们的错误处理程序，同样需要知道发生错误时的CPU现场情况。可是，当我们开始执行自己的错误处理程序时，发现`Trapframe`没了！所以，在此之前，我们需要保留必要的信息至内存的某个地方。使得我们跳转后，可以获取信息。

那么，这个内存区域可以是之前的栈（Trapframe那个）吗？不行（会很麻烦）！因为你不知道现在`esp`指向哪里，你或许会说，用内联汇编呀（`push`所需信息），但这会使得代码很糟糕！而且不一定能成，因为我没仔细思考过。。

所以，`JOS`的虚拟地址空间提供了`User Exception Stack`区域，专门用来作为自己错误处理程序时的运行栈。好了，有了这片区域，我们可以把东西放那里，并且继续执行处理程序。

你必须考虑一个问题，万一处理程序运行时又产生一个错误，那么我们的数据又写在这片区域吗？并不能，你写了就会把上一次错误处理的数据冲刷掉！所以，你应该从现在的栈指针（现在在UXSTACK里）以上的空间来存储！

问题又来了，错误处理程序完成后，需要返回中断之前的状态！在恢复上下文期间，你又想要使得`eip`恢复，又想`esp`恢复。如果先恢复`esp`，你的`eip`就消失在人海，再也回不去了。如果你先恢复`eip`，那你的恢复`esp`指令将永远无法执行！所以，我们可不可以将`eip`先放到老`esp`的上方一个字，再修改老`esp`的值指向上一个字。之后，先恢复`esp`再`ret`，就能完美解决我们的问题！（巧妙吧）

可是，老`esp`的上一个字可以写吗？为了保证可写（不会冲掉其他数据），我们在存储上下文至`UXSTACK`时，就保留一个空白的字。（现在知道为什么要保留一个字了吧）当第一次切换到异常栈时，老`esp`是在用户栈里头，而用户栈上面的一个字时没有用过的，所以可以放心写。

所以，`_pgfault_upcall`实质上就是一个包装函数，它包装`_pgfault_handler`，并在`handler`完成返回后，恢复上下文。

如果说，你到现在都不懂的话，我建议你直接放弃！（哈哈哈，开玩笑，再仔细读吧）

### 1.`page_fault_handler()`微调

经过我上面这么一番叙述后，这里的工作就想当明了！

你需要将官网上那些信息写到合适的区域！并且通过修改`tf`，使得`env_run`直接跳转至`_pgfault_upcall`！

### 2.实现`_pgfault_upcall()`

我们只需实现`handler`完成返回后的恢复上下文工作！我上面说的很详细了，就是要先将`eip`写到恢复栈指针的上一个字，再把恢复栈指针指向它的上一个字。通用寄存器的恢复就是`movl`就行了，不过，这里要小心每次恢复了一些东西后，就会被限制不能使用一些东西和操作！！

### 3.实现`set_pgfault_handler()`

这个最简单，就是设置`handler`的地址。如果第一次设置，则要分配异常栈空间和进程控制块中`upcall`的指向即可。

### 4.实现写时复制的`fork()`

先复述一下思路：

1. `fork()`

   1. 设置错误处理函数的入口地址
   2. 调用系统调用`sys_exofork()`。从这里开始，子进程会在此处继续执行（系统调用时已经保存上下文，而新进程又被初始化为这个上下文）。那么，我们要设置分支：如果返回值为0，则子进程在执行；如果为正数，就是父进程。
   3. 对于子进程，我们要修改全局变量`thisenv`，这个变量在内存，而我们的子进程指向父进程的那个页，那个页时父进程的变量值。所以我们要改回来！
   4. 对于父进程，有以下三步：
      1. 从0至UXSTACKTOP-PGSIZE的地址空间中，只映射父进程有映射的页给子进程！使用`duppage`
      2. 为子进程设置用户异常栈（全新的）。因为我们子进程被创造出来，是在`sys_exofork()`返回后开始执行，也就是说没有任何的错误处理，自然它的异常栈就应该是新的！！！
      3. 设置子进程的`upcall`地址，因为子进程被创建时，这个成员是0！
   5. 设置子进程状态为可运行，然后大功告成。

2. `getPte(void *addr)`

   这个用来获得对应虚拟地址`addr`，在当前进程的页表的`pte`。获取他就可以获取虚拟地址所在页的权限，`duppage`和`pgfault`都要用到它！可是如何实现呢？？

   我们在用户进程，是不可以使用内核函数`pgdir_walk`来获得`pte`的。所以，内核设计虚拟地址空间时，保留了一个`UVPT`的区域。用这个区域来获取Page Table！！你可能好奇这是在什么时候映射的，这是在`mem_init()`时就设置了。

   ```c
   kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
   ```

   `UVPT`的`PDX`为`0x3bd`，`PTX`是0，那我们使用`UVPT`这个虚拟地址遍历一遍得到的页面是什么呢？答案就是`env_pgdir`第一项指向的那个page table！因为页目录0x3bd项指向了他自己，所以现在页目录被看作页表，由于`PTX`为0，所以第一项pde指向的page table（这个页表被看作page）

   `UVPD`的`PDX`是`0x3bd`，`PTX`也是`0x3bd`，走一遍就会得到页目录所在的那个页！

   你可能会问了，上面那个代码不是指向的是`kern_pgdir`吗？其实，在我们`env_setup_vm`时：

   ```c
   e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;
   ```

   所以，我们要想获得虚拟地址`addr`的`pte`时，我们只需利用`uvpt`/`uvpd`来像`pgdir_walk`那样获取即可。`uvpt`/`uvpd`类型分别是`pte_t *`/`pde_t *`。所以`uvpd[PDX(addr)]`可获取`pde`；`uvpt[PGNUM(addr)]`可获取`pte`。

3. `duppage(envid_t envid, unsigned pn)`

   1. 因为参数是页号（虚拟），所以要转成虚拟地址
   2. 获取对应pte，再获取权限perm
   3. 根据perm决定复制策略：
   4. 如果是PTE_W or PTE_COW，那么我们先将子进程的对应pte指向该页，并且其权限为PTE_COW，且不能有PTE_W（这样就能在写时抛出异常）。再将原来pte权限删除PTE_W，加上PTE_COW。
   5. 如果说read only page，直接复制映射，设置好相应权限即可。

4. `pgfault(struct UTrapframe *uft)`

   1. 首先判断是不是写错误，是的话继续往下，不是panic即可。
   2. 获取错误地址pte，获取其权限。
   3. 如果权限有PTE_COW，继续往下，否则panic
   4. 分配一页PFTEMP，并将错误地址所在页的内容复制过去。
   5. 将错误地址的pte指向PFTEMP指向的那个页即可。

实现以上功能请善用我们之前实现的系统调用，以及一些可用的宏（要知道那些宏是可用的，请阅读`inc/lib.h`；或者你可以在带有语法提示的编辑器编写代码）。

由于现在我们的内核比较大了，代码比较多了。调试起来非常难（可能是我不会调试），反正每次找bug都找好久。所以接下来给大家说下一些**注意点**/**错误经验**：

1. 这个练习会把你之前实验的错误都暴露出来，我的bug就是父进程`1000` `fork` 出子进程`1001` `1002`后，`1001`的异常栈爆了，`1002`输出个`i am '1'`就`Triple fault`。这个bug很奇怪啊，我调试好久，发现1001的错误原因是修改`thisenv`时抛出`cow`错误，在进入`pgfault`时出错了（指向一个错误的地址），又抛出一个错误，然后这样不断循环，直至爆炸。所以我为什么我的pgfault地址是错的？原因是存有`pgfault`地址（即变量`_pgfault_handler`）所在的页面被修改了！为什么被修改？这里我想了很久，最后我得出的结论是有可能他被free掉了！为什么被`free`掉？这可能和ref的数目错误有关。果然，我在`load_icode`时，所有的页面`pp_ref`都为`0`！应该为`1`才对！修改回来后，直接通过。。。真的无语了。。
2. `user_mem_check assertion failure for 0xeebffxxx`就是你的异常栈爆了，而这种错误，一般是你的`pgfault`地址错了，使得`upcall`在`jmp`时又抛出一个页面错误。或者是你的`pgfault`里访问某块内存，又出错。这样通常是你的`get fault va pte`没写对，也就是查`uvpt/uvpd`没写正确。
3. 我们`duppage()`时，官网说先让子进程映射，父进程再重新映射是有道理的。因为我们要 `duppage` 用户正常栈，而在`duppage`它时，如果你先让父进程变成COW，那么父进程在使子进程COW之前，使用了堆栈，导致一个page fault，将alloc新的堆栈，再进行使用。好了，现在子进程指向了父进程的堆栈（而父进程有PTE_W权限，这意味着什么？这意味着子进程的堆栈在被父进程随便蹂躏！！！）所以，现在懂了吧。
4. 你的`sys_page_map`应可以使得原本存在的映射`remove`掉，然后再重新映射。而不是分成先`sys_page_unmap`再`sys_page_map`（这样，在执行map之前，如果又用到了这一页，那将会抛出错误！）换句话说，你的`page_insert`是要`remove`掉之前的映射。
5. 如果发生错误，我建议大家将映射时的页面信息打印到屏幕上（`pp_ref`），还可以在为COW页alloc新页时作出提示，这样可以帮助找出bug。
6. 子进程第一次修改COW页是在`thisenv`赋值那里。父进程第一次修改COW页是duppage用户栈页那里，第二次fork会调用`set_pgfault_handler`，那里会第二次修改COW页。因为`thisenv`/`_pgfault_handler`是全局变量，在`0x802000`那页。

好了，我们现在`make grade`应该能通过Part B了！

