# MIT6.828-2017Lab4PartC 学习过程

### 0.开始

实现时钟中断以及进程通信。

实验的所有代码提交可参见[我的GitHub仓库](https://github.com/astzls213/MIT6.828-2017Lab)

我更建议大家看`github`仓库那个`experience`文件夹里头的，因为知乎对md格式排版不是很好。。最后，如果你觉得干货满满，可以点个赞鼓励下我！！嘻嘻！如果有什么不懂的，可以评论留言告诉我。

### 1.添加外围设备中断入口程序

很简单，和之前一样。在`trapentry.S`里用宏定义，然后再`trap_init()`为`idt`设置对应入口地址。

唯一要注意的是，`trap()`会检查内核处理异常中断时，要关中断（即`FL_IF`要为0），那么怎么才能在中断时关中断呢？在我们的`SETGATE`宏里，第二个参数是指明`trap`还是interrupt，如果是`interrupt`，则会保存中断前保留当前eflag，然后`FL_IF`置0，然后`iret`时恢复。如果是`trap`，则不会这样。所以，我们要把所有异常/中断的第二个参数都为0（设置为中断类型），这样才能通过那个`assert`。

### 2.在`trap_dispatch()`设置时钟中断处理程序

这个更简单，要注意的是不要忘了在`sched_yield()`前`lapic_eoi()`。这个是关闭时钟中断信号的，如果不关闭，会怎样？会一直告诉cpu要切换进程！！抽象一下，就是时间片为0了。

### 3.实现进程间通信

官网把这个说得有点复杂，其实就是这么个意思：

1. `sys_send`就是要修改别人进程控制块的几个成员，但仅当该进程块的`recving`成员为`true`，才做修改。否则返回错误码。而`ipc_send`，就是通过系统调用的返回码决定是不是要再重新调用`sys_send`。设置完了以后，就要把人家设置成可运行，然后就行了。
2. sys_recv就是把自己的recving设置成true，然后让自己block起来。

这样，我们的PartC就实现了。可是，虽然这个Part很简单，但是由于之前写错了一段代码，导致出现非常奇怪的bug，然后还无法调试（错误很随机），我先跟大家说一下是什么bug：

首先，我尝试运行primes时，多CPU时，运行到差不多第80几个素数就会报错，要么是kernel page fault，要么是什么pa2page的pa参数错误。我一开始以为是我的内存管理又写错了。。但我检查了一下午，感觉都没问题（事实上确实没问题）。然后，我用单cpu运行了一下，发现可以正常运行！！！然后我又以为是并发问题，可是，我的大内核锁也设置好了，进入内核也关中断了，为什么还是出现这么奇怪的bug呢？？后来，我去github找别人的代码，一个个源文件排查（即将某个源文件替换成别人的），编译，运行，最终是trap.c这个源文件出了问题。最后经过对比，原来是`trap_init_percpu`的`ts_esp0`的代码写错了。就是初始化内核堆栈那句：

```c
// 错误的
thiscpu->cpu_ts.ts_esp0 = KSTACKTOP + n * gap_stack;
// 正确的
thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - n * gap_stack;
```

对，就是这么个符号打错，让我debug了2天。。当时用vi打的，由于vi快捷键比较多，然后比较累，就造成了这么个无语的错误。所以为什么出错就很简单了。其他cpu的内核堆栈指向未分配的物理页，当某一进程用到这些内存时，内核会对其进行破坏！导致无语的bug。